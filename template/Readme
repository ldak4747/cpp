这里主要对template的各种重要细节和不易理解容易出错的地方进行总结, 旨在理解和熟练的掌握运用template:

1、function:
    如何在模板函数中, 实现对返回值的泛型, 答案是调用方对返回值类型做显式实例化
    这样的使用可能不是特别常见, 但应该掌握, 而更应该掌握的是, 通过这例子, 提高对template的理解和运用

2、how_to_define_template_member_function_not_inline:
    长期以来对于模板类的模板函数, 它的声明和定义必须在一起, 也就是必须是一个内联成员函数;
    那么真的必须是这样吗?
    答案是否定的! 答案是: 连续两个template.....
    通过这个东西, 有没有再加强一点, 对template的理解和运用?

3、可以指定默认的模板泛型类型
    只要必须是编译期间可推断的类型, 就可以

4、指定右值整型常量为模板泛型参数
    这招相当于在编译期间给类定义默认成员值, 在c++11可以声明时初始化的情况下, 这招优势不再明显

二、通过实现智能指针, 强化template的基础使用能力:
    c++11引入了智能指针, 实现了根据自己的业务逻辑, 不再需要代码决定动态内存的释放, 大大减少了因动态内存分配释放导致的错误发生的几率;

    智能指针所指向的对象应该是在堆上申请的动态内存对象而不是栈上分配的内存的对象(这里是"应该", 意思是可以强行不是堆对象, 方式是在创建智能指针时, 通过自己指定析构方法, 但是很不推荐在智能指针上应用非动态对象).
    
    分为独占型(unique_ptr)和共享型(shared_ptr)两类针对对象持有方式的智能指针类型, 前者意味着指向的对象只能由当前指针持有, 后者意味着指向的对象可以由多个指针持有;
    
    前者相对容易理解, 后者因可以由多个智能指针持有所以稍难理解运用, 事实上它们都是由内部的一个引用计数器, 决定是否可以被赋值或构造其他对象;
                最大引用计数
    unique_ptr  1
    shared_ptr  N
    
    对于unique_ptr, 如果通过初始化或赋值指向了一个对象, 那么除非它放弃对这个对象的继续指向, 其他智能指针不能指向该对象; 当智能指针主动放弃指向(reset)或生命周期完结遭析构;

    对于shared_ptr, 当一个内存对象被一个或N个shared_ptr智能指针指向时, 堆上会有一个引用计数器, 记录有1个或N个shared_ptr指向它, 当一个或N个shared_ptr释放指向时(reset、被重新赋值、生命周期完结遭析构), 堆上的这个引用计数器, 同样会对计数个数减掉1或N;
    直到最终计数器为0, 也就是不再有任何一个shared_ptr指向这个内存对象时, 那么会释放掉这个内存对象了, 因为不再需要它了.
    而堆上的这个引用计数器, 还会根据是否再有weak_ptr弱引用指向这个计数器的情况, 决定是否释放引用计数器. weak_ptr是shared_ptr的配套使用, 某种角度上, 相当于shared_ptr的"镜像", 它的用途是避免shared_ptr循环引用导致内存无法释放;

    小节: unique_ptr是独占型智能指针, 进程中同一个内存对象只能由一个unique_ptr指向; 除非这个unique_ptr放弃指向;
          shared_ptr是共享型智能指针, 进程中可以有多个shared_ptr同时指向一个内存对象, 根据是否一个shared_ptr都没有再指向这个内存对象, 决定是否释放内存对象;

    另外需注意, unique_ptr和shared_ptr都不是线程安全的, 尤其指的是shared_ptr, 因为unique_ptr是独占的. 具体讲, 智能指针的reset、赋值是线程不安全的, 它需要修改对象指针指向、计数器指针指向、增减计数值, 这些步骤是不原子的. 所以如果智能指针在多线程中作为共享资源使用时, 需要做互斥.

    现在, 仔细描述下shared_ptr的循环引用是怎么回事;
    比如有结构体A, A中包括shared_ptr<B>的成员pb;
    还有个结构体B, B中包括shared_ptr<A>的成员pa;

    在应用程序中, 先后创建了shared_ptr<A>和shared_ptr<B>的两个变量sa和sb;
    并且sa的类成员pb指向sb;
    并且sb的类成员pa指向sa;

    这时候, sa和sb的引用计数是多少?
    都是2

    当sa和sb被析构时, 类成员变量pb和pa被释放, 释放时会调用析构函数, 析构函数会自减计数1, 这时:

    sa和sb的引用计数是多少?
    都是1

    那么问题来了, 因为引用计数没有到0, 变量sa和sb在被析构后, 它们的析构函数都认为, 还不能释放动态内存;

    解决方法是什么呢?

    1、需要让类成员变量pb、pa, 还能够继续行使智能指针功能, 而不是改成使用裸指针;
    2、同时不能因计数无法降到0, 导致内存无法释放

    解决方法是: weak_ptr的出现
    1、weak_ptr不会增加引用计数;
    2、通过weak_ptr还能够得到一个新的shared_ptr
    3、当这个新的shared_ptr析构时, 就会自然减掉引用次数, 而不是像以前那样, 必须等到类实例sa、sb被释放时, 才去减引用次数;

    现在就打开SharedPtr.hpp, 先看下shared_ptr的实现, shared_ptr可以由一个weak_ptr构造, 指向weak_ptr指向的内存对象ptr和引用计数器cnt, 这就是如何实现的, 通过一个weak_ptr再获取shared_ptr的方法;
    再看看weak_ptr的实现, 它虽然也有同样的内存对象指针ptr和引用计数器cnt, 但它在被构造之后, ptr和cnt虽然都指向了shared_ptr的ptr和cnt, 但cnt中的实际引用计数(u)并未加1, 也就是说weak_ptr不会真正增加实际引用计数, 它只是增加了一个弱引用计数(wu), 这个其实没什么用, 唯一用途是, 当实际引用计数(u)和弱引用计数(wu)都为0时, 计数器也不再需要了, 也应该被释放.
    weak_ptr没有直接被用于获取和使用内存对象的权利, weak_ptr没有*和->的重载方法, 它只能被shared_ptr用于"过桥".

    


    最后, 无论unique_ptr还是shared_ptr, 都是资源初始化即实现(RAII)的实践, 不过它们也都可以无参初始化, 此时ptr和cnt都不会去申请动态空间;

    -----------------分--------割--------线-------------------

    关于智能指针的介绍, 到这里应该非常充分了, 接下来就是如何动手实现它们:

    shared_ptr应该:
    1、可以无参初始化, 这时什么也不做, ptr和cnt均保持默认为空;
    2、可以由另一个shared_ptr构造, 这时首先要先和当前可能已经指向的对象脱离干系, 包括ptr重新指向新的ptr, 减少先前已经指向对象的引用计数, 增加当前新指向的对象的引用计数;
    2.1、注意, 如果之前对象只有它自己指向, 那么这时候需要析构内存对象, 即delete ptr && ptr = nullptr; 同时根据弱引用计数是否也是为0, 决定是否也应释放掉计数器;

    3、可以由一个weak_ptr构造, 和2无区别;
    4、可以被另一个shared_ptr赋值, 和2无区别;
    5、可以由reset方法, 改为指向另一个动态对象;为新的内存对象创建计数器并初始化实际引用计数为1, 其他和2无区别
    6、支持*、->的重载方法, 用于使用对象;
    7、需要use_count方法, 用于指示当前实际引用计数;
    8、weak_ptr<T>必须是友元类, 因为weak_ptr需要由shared_ptr构造, 所以需要能够访问shared_ptr的私有成员ptr和cnt;

    作为shared_ptr的跟班, weak_ptr应该:
    1、可以无参初始化, 同样是什么也不做, ptr和cnt均保持默认为空;
    2、可以由另一个weak_ptr构造, 标准库并不会增加弱引用计数, 这里的实现是增加弱引用计数;
    3、可以由一个shared_ptr构造;
    4、可以reset掉, 即放弃指向ptr并做弱引用计数减1, 而不能通过reset指向其他对象; 如果需要指向其他weak_ptr或shared_ptr指向的对象, 先reset掉再重新通过赋值去指向;
    5、可以被另一个shared_ptr赋值, 作为另一个shared_ptr的桥;
    6、也可以被另一个weak_ptr赋值, 同样作为桥;
    7、lock方法, 这是通过weak_ptr作桥, 创建一个新的shared_ptr, 解决循环引用问题的标准姿势; 具体很简单, 由自己作为参数创建一个新的shared_ptr;
    8、expired方法, 用于判断实际引用计数是否已经为0了, 为0或者计数器都不存在了返回true, 意为到期了; 计数器存在且实际引用计数还不为0则返回false;
    9、use_count方法, 返回弱引用计数;
    10、release方法, 与shared_ptr不同的是, weak_ptr的release方法只会减少弱引用计数, 当计数器存在且实际引用和弱引用都为0时, weak_ptr有权释放计数器;
    11、shared_ptr<T>同样必须是友元类, 因为shared_ptr需要以weak_ptr为参数构造自己, 这时是需要访问weak_ptr私有成员ptr和cnt的;
    

